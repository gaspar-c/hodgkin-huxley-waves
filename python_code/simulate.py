"""

This module contains:

    class CurrentI:             create object with parameters for external current input i(x,t)

    class SpikeAnalyser:        create object that analyses the spikes generated by the HH neuron
                                while the model is simulated

    function run_simulation:    run simulation

"""

import time
import glob
import numpy as np
import matplotlib.pyplot as plt
from python_code.post_simulation import store_peak_records, store_speed_records


class CurrentI:
    def __init__(self, value, start_time=0, stop_time=np.inf, x_inj=np.array([0])):
        self.value = value              # muA,  value of current to be injected
        self.start_time = start_time    # ms,   simulation time at which current starts
        self.stop_time = stop_time      # ms,   simulation time at which current stops
        self.x_inj = x_inj              # -,    array with mesh locations where current is injected


class SpikeAnalyser:
    def __init__(self,
                 spike_x=0.05,          # %,    location in axon where spikes are detected
                 threshold=60,          # mV,   voltage threshold where spikes are detected
                 min_steps=3,           # -,    minimum number of time steps to detect changes
                 final_spike=np.inf,    # -,    if < inf, sim will end after final_spike crosses through
                 rec_speeds=None,       # -,    record speeds from spikes whose indices are given
                 rec_peaks=None,        # ms,   record peak coordinates every X ms (for characteristic curves)
                 sort_peaks=True,       # -,    if True, sorts peak recordings by spike
                 ):

        # initialise spike analyser parameters
        self.spike_x = spike_x
        self.threshold = threshold
        self.min_steps = min_steps
        self.final_spike = final_spike
        self.rec_peaks = rec_peaks
        self.sort_peaks = sort_peaks

        # if no rec_speeds is specific, set it to -1
        if rec_speeds is None:
            self.rec_speeds = np.array([-1])
        else:
            self.rec_speeds = np.sort(rec_speeds)

        self.k = 0                      # count simulation time steps
        self.dt = 0                     # simulation time step
        self.mesh_size = 0              # simulation mesh size

        # variables for counting spikes at the left detection site
        self.n_spikes_left = 0          # count number of spikes
        self.spiking_left = False       # flag if spike is being detected
        self.k_spike_start_left = 0     # time step when spike start was last detected
        self.k_spike_end_left = 0       # time step when spike end was last detected

        # variables for counting spikes at the right detection site
        self.n_spikes_right = 0         # count number of spikes
        self.spiking_right = False      # flag if spike is being detected
        self.k_spike_start_right = 0    # time step when spike start was last detected
        self.k_spike_end_right = 0      # time step when spike end was last detected

        # initialise arrays to store spike periods and wavelengths
        self.periods = np.array([])
        self.wavelengths = np.array([])

        # initialise array to store peak coordinates (for characteristic curves)
        self.track_peaks = np.empty((0, 3))

        # declare variables to detect spike front coordinates (for speed calculation)
        self.n_spikes_mesh = None       # count number of spikes detected at each point in mesh
        self.check_spiking_mesh = None  # check if spike is being detected at each point in mesh
        self.k_spike_start_mesh = None  # time step when spike start was last detected at each point in mesh
        self.k_spike_end_mesh = None    # time step when spike end was last detected at each point in mesh
        self.spike_x_mesh = None        # array that indicates the mesh detection points

        # store spike front coordinates, for speed calculation
        self.spike_front_coord = np.empty((0, 3))

    # initialise spike analyser variables that depend on simulation parameters
    def analyser_init(self, mesh_size):
        self.mesh_size = mesh_size

        # initialise variables to detect spike front coordinates (for speed calculation)
        self.check_spiking_mesh = np.zeros(self.mesh_size)
        self.n_spikes_mesh = np.zeros(self.mesh_size)
        self.k_spike_start_mesh = np.zeros(self.mesh_size)
        self.k_spike_end_mesh = np.zeros(self.mesh_size)
        self.spike_x_mesh = np.zeros(self.mesh_size)
        self.spike_x_mesh[int(self.spike_x * self.mesh_size):
                          int((1 - self.spike_x) * self.mesh_size) + 1] = 1

    # perform all spike analyser checks, to be called at every time step
    def analyser_checks(self, sim_time, voltage):

        # initialise spike analyser variables on the first integration step
        if self.k == 0:
            self.analyser_init(len(voltage))

        # count time steps
        self.k += 1

        # if last spike to be recorded has not finished passing through the axon
        if self.n_spikes_right <= self.rec_speeds[-1]:

            # get spike front coordinates at each point in detection mesh (for speed calculation)
            self.check_spike_fronts(voltage)

        # check spikes at the left detection site
        self.check_spike_left(voltage)

        # check spikes at the right detection site
        self.check_spike_right(voltage)

        # record spike peak coordinates (for characteristic curves)
        if self.rec_peaks is not None:
            if sim_time % self.rec_peaks < (sim_time / self.k):
                self.get_peak_coords(voltage)

        # check if simulation should end
        end_flag = False
        if self.final_spike < np.inf:
            end_flag = self.check_sim_end(sim_time)

        return end_flag

    # check spikes at left detection site, used for counting how many spikes are generated
    def check_spike_left(self, voltage):

        # detect beginning of spike
        if (not self.spiking_left) and (self.k - self.k_spike_end_left > self.min_steps) and \
                (-voltage[int(self.spike_x * self.mesh_size)] > self.threshold):

            self.spiking_left = True
            self.n_spikes_left += 1
            self.k_spike_start_left = self.k

        # detect end of spike
        if self.spiking_left and (self.k - self.k_spike_start_left > self.min_steps) and \
                (-voltage[int(self.spike_x * self.mesh_size)] < self.threshold):

            self.spiking_left = False
            self.k_spike_end_left = self.k

    # check spikes at right detection site, get spike periods and wavelengths
    def check_spike_right(self, voltage):

        # detect beginning of spike
        if (not self.spiking_right) and (self.k - self.k_spike_end_right > self.min_steps) and \
                (-voltage[int((1 - self.spike_x) * self.mesh_size)] > self.threshold):

            self.spiking_right = True
            self.n_spikes_right += 1

            # get period from last spike
            if self.n_spikes_right > 1:
                self.periods = np.append(self.periods, [self.k - self.k_spike_start_right])

            self.k_spike_start_right = self.k

            # detect peaks and their position
            peaks = np.argwhere(
                (-voltage[2:-2] > self.threshold) *
                (-voltage[2:-2] > -voltage[1:-3]) *
                (-voltage[2:-2] > -voltage[0:-4]) *
                (-voltage[2:-2] > -voltage[3:-1]) *
                (-voltage[2:-2] > -voltage[4:])
            )

            # remove peaks outside detection range
            peaks = peaks[(peaks <= (1 - self.spike_x) * self.mesh_size) &
                          (peaks >= self.spike_x * self.mesh_size)]

            # get wavelength between first peak and the next
            if len(peaks) > 1:
                self.wavelengths = np.append(self.wavelengths, [peaks[-1] - peaks[-2]])

        # detect end of spike on the right side
        if self.spiking_right and (self.k - self.k_spike_start_right > self.min_steps) and \
                (-voltage[int((1 - self.spike_x) * self.mesh_size)] < self.threshold):

            self.spiking_right = False
            self.k_spike_end_right = self.k

    # get spike front coordinates, for speed calculation
    def check_spike_fronts(self, voltage):
        """
        tracks at which time spikes cross the voltage threshold
        for each point in the spatial mesh. this can be used
        to estimate the spikes' velocity (not in this function)
        """

        # detect beginning of spike at each position in detection mesh
        spiking_idx = (self.spike_x_mesh == 1) * (self.check_spiking_mesh == 0) * \
                      (self.k - self.k_spike_end_mesh > self.min_steps) * \
                      (-voltage > self.threshold)

        # track if a point in mesh detected a spike
        self.n_spikes_mesh[spiking_idx] += 1
        self.k_spike_start_mesh[spiking_idx] = self.k

        # check if spikes crossing the detection mesh are to be recorded
        for spike_idx in self.rec_speeds:

            # place in mesh where spike_idx is crossing
            spike_idx_x = np.argwhere((self.n_spikes_mesh == spike_idx) *
                                      (self.check_spiking_mesh == 0) *
                                      spiking_idx)

            # if one location is detected, store spike front coordinates
            if len(spike_idx_x) > 0:
                if len(spike_idx_x) == 1:
                    self.spike_front_coord = np.append(self.spike_front_coord,
                                                       [[spike_idx, spike_idx_x[0][0], self.k]],
                                                       axis=0)
                else:
                    print('Error: detected spike %d passing at several locations %s' % (spike_idx, spike_idx_x))

        # track locations where spike has been detected
        self.check_spiking_mesh[spiking_idx] = 1

        # detect end of spike at each location
        stopped_idx = (self.spike_x_mesh == 1) * (self.check_spiking_mesh == 1) * \
                      (self.k - self.k_spike_start_mesh > self.min_steps) * \
                      (-voltage < self.threshold)
        self.check_spiking_mesh[stopped_idx] = 0
        self.k_spike_end_mesh[stopped_idx] = self.k

    # record voltage peak coordinates (for characteristic curves)
    def get_peak_coords(self, voltage):

        # spatial range of recording
        start_idx = int(0.02 * self.mesh_size)
        end_idx = int(0.98 * self.mesh_size)

        # find peaks larger than threshold and two consecutive neighbors
        peaks = start_idx + np.argwhere(
            (-voltage[start_idx:-2] > self.threshold) *
            (-voltage[start_idx:-2] > -voltage[start_idx + 1:-1]) *
            (-voltage[start_idx:-2] > -voltage[start_idx + 2:]) *
            (-voltage[start_idx:-2] > -voltage[start_idx - 1:-3]) *
            (-voltage[start_idx:-2] > -voltage[start_idx - 2:-4])
        )

        # remove peaks outside recording range
        peaks = peaks[peaks <= end_idx]

        # get peak heights
        heights = -voltage[peaks]

        # store peak coordinates
        if len(peaks) > 0:
            for j in range(len(peaks)):
                self.track_peaks = np.append(self.track_peaks,
                                             [[peaks[j], self.k, heights[j]]],
                                             axis=0)

    # check if simulation should end
    def check_sim_end(self, sim_time):
        end_flag = False

        # if more spikes passed the right site than final_spike, unless spikes are being recorded
        if (self.n_spikes_right > self.final_spike) and (self.n_spikes_right >= self.rec_speeds[-1]):
            end_flag = True

        # if more than 100 ms have passed and not more than 1 spike passed the left site
        if (self.n_spikes_left <= 1) and (sim_time > 100) and (self.n_spikes_left == self.n_spikes_right):
            end_flag = True

        # if more than 5x the last period has passed on the right site without new spikes
        if (self.n_spikes_right > 1) and \
                (self.k - self.k_spike_end_right > 5 * self.periods[-1]):
            end_flag = True

        return end_flag

    # return string with spike analyser data
    def get_text(self):
        text = ' spiked %d times\n' % self.n_spikes_left

        if len(self.periods) > 0:
            text += ' last period = %d * dt\n' % self.periods[-1]
        if len(self.wavelengths) > 0:
            text += ' last wavelength = %d * dx\n' % self.wavelengths[-1]

        return text


# run simulation for the given sim object
def run_simulation(sim):

    # if results are to be plotted while simulation runs
    if sim.live_plot:

        # create figure for live simulation plotting
        fig_width = 30 / 2.54
        fig_height = 10 / 2.54
        fig, ax = plt.subplots(1, 2, figsize=(fig_width, fig_height), gridspec_kw={'width_ratios': [3, 1]})
        ax_plot = ax[0]
        ax_text = ax[1]

        # plot space vs voltage
        (ln_plot,) = ax_plot.plot(np.arange(0, sim.mesh_size) * sim.dx, -sim.v_array, lw=1, color='gray', animated=True)
        ax_plot.set_ylim([-20, 110])
        ax_plot.set_ylabel('-V (mV)')
        ax_plot.set_xlabel('x (cm)')
        for spine in ['top', 'right']:
            ax_plot.spines[spine].set_visible(False)

        # draw lines to show where spikes are being analysed
        if sim.spike_analyser is not None:
            ax_plot.axvline((1 - sim.spike_analyser.spike_x) * sim.neuron.length, ls='--', c='lightgray')
            ax_plot.axvline(sim.spike_analyser.spike_x * sim.neuron.length, ls='--', c='lightgray')
            ax_plot.axhline(sim.spike_analyser.threshold, ls='--', c='lightgray')

        # initialise subplot showing simulation parameters
        ax_text.set_axis_off()
        sim_text = sim.get_text()
        ln_text = ax_text.text(0, 1, sim_text, va='top', ha='left', animated=True)

        # configure live plotting
        plt.show(block=False)
        plt.pause(0.01)
        bg = fig.canvas.copy_from_bbox(fig.bbox)
        ax_plot.draw_artist(ln_plot)
        ax_text.draw_artist(ln_text)
        fig.canvas.blit(fig.bbox)

    # store real time before actual simulation starts
    clock_time = time.time()

    # start simulation
    while 1:

        # run one simulation time step, end_flag says whether sim should end
        end_flag = sim.step_solve()

        # update live plots at every 1 ms
        if sim.live_plot and sim.sim_time % 1 < sim.dt:

            # get string with solver data
            sim_text = sim.get_text()

            # get string with spike analyser data
            if sim.spike_analyser is not None:
                sim_text += '\n\n%s' % sim.spike_analyser.get_text()

            # update live plots
            fig.canvas.restore_region(bg)
            ln_plot.set_ydata(-sim.v_array)
            ln_text = ax_text.text(0, 1, sim_text, va='top', ha='left')
            ax_plot.draw_artist(ln_plot)
            ax_text.draw_artist(ln_text)
            fig.canvas.blit(fig.bbox)
            fig.canvas.flush_events()

        # end simulation if end_flag is true
        if end_flag:
            break

    # print how long simulation took
    print('%s: simulated in %.3f seconds' % (sim.name, time.time() - clock_time))

    # close live plot figure
    if sim.live_plot:
        plt.close(fig)

    # save simulation log file with solver and spike analyser data
    f = open('simulation_results/' + sim.name + '/log.txt', 'w')
    sim_text = sim.get_text()
    if sim.spike_analyser is not None:
        sim_text += '\n\n%s' % sim.spike_analyser.get_text()
    f.write(sim_text)
    f.close()

    # create snapshot figures
    snapshot_filenames = glob.glob('simulation_results/' + sim.name + '/*ms.txt')
    for snapshot_file in snapshot_filenames:
        print(snapshot_file)
        v_snapshot = np.loadtxt(snapshot_file)
        plt.plot(np.arange(0, sim.mesh_size) * sim.dx, v_snapshot, lw=1, color='gray', animated=True)
        plt.ylim([-20, 110])
        plt.ylabel('-V (mV)')
        plt.xlabel('x (cm)')
        plt.savefig(snapshot_file.replace('.txt', '.png'))
        plt.close()

    # perform post simulation spike analyser operations
    if sim.spike_analyser is not None:

        # store spike peak recordings
        if sim.spike_analyser.rec_peaks and sim.spike_analyser.n_spikes_left > 0:
            store_peak_records(sim)

        # store speed recordings
        if len(sim.spike_analyser.rec_speeds) > 0:
            store_speed_records(sim)

        # store spike periods
        if len(sim.spike_analyser.periods) > 0:
            np.savetxt('simulation_results/' + sim.name + '/periods.txt', sim.spike_analyser.periods * sim.dt)

            # store spike wavelengths
            if len(sim.spike_analyser.wavelengths) > 0:
                np.savetxt('simulation_results/' + sim.name + '/wavelengths.txt',
                           sim.spike_analyser.wavelengths[:len(sim.spike_analyser.periods)] * sim.dx)

    print('%s: done' % sim.name)
